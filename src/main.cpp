/*
 * main.cpp
 *
 * Part of hbcxx - executable C++ source code
 *
 * Copyright (C) 2014 Daniel Thompson <daniel@redfelineninja.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 */

#include <signal.h>

#include <cstdlib>
#include <algorithm>
#include <exception>
#include <iostream>
#include <list>
#include <string>
#include <utility>
#include <vector>

#include <boost/filesystem.hpp>

#include "string.h"
#include "system.h"
#include "util.h"
#include "CompilationUnit.h"
#include "Launcher.h"
#include "Options.h"
#include "PrePreProcessor.h"
#include "Toolset.h"

using hbcxx::ScopeExit;
namespace file = boost::filesystem;

/*!
 * A complete alternative program triggered by --hbcxx-exec-wrapper
 *
 * When launched as an exec wrapper we exec our arguments just as we
 * find them with the exception of arg0 which we substitute if an alternative
 * has been provided using an environment variable.
 *
 * This code path is used to ensure programs supervised by gdb are launched
 * with the correct value in arg0.
 */
static int exec_wrapper(std::list<std::string>& args)
{
	auto newarg0 = std::getenv("HBCXX_SUBSTITUTE_ARG0");
	auto oldarg0 = args.front(); // this was originally passed in arg1

	// make sure the variable is not observed by the sub-process
	hbcxx::unsetenv("HBCXX_SUBSTITUTE_ARG0");

	if (newarg0) {
            args.pop_front();
            args.emplace_front(newarg0);
	}

	hbcxx::exec(oldarg0, args);

	// unconditionally throw an error; exec should never return
	return 127;
}

class ArgumentError : public std::exception {
};

/*!
 * Determine which program to build.
 *
 * Pops arguments from args until we can determine what program to build. At
 * this point args has had all toolset options removed and contains only those
 * arguments that must be passed to the program once we have built it.
 */
static std::string handleArguments(std::list<std::string>& args, Toolset& toolset)
{
    auto showHelp = bool{false};

    while (!args.empty()) {
        auto arg = args.front();
	args.pop_front();

	// cherry pick arguments that might be used to trigger help information.
	if (arg == "--help" || arg == "-h")
	    showHelp = true;

	// if the file exists we will try to execute it
	if (file::exists(arg))
	    return arg;

	// otherwise we pass on the flag to the toolchain
	toolset.pushFlag(arg);
    }

    if (showHelp)
	Options::showUsage(); // calls std::exit()

    throw ArgumentError{};
}

static int run(std::list<std::string>& args)
{
    auto ppp = PrePreProcessor{};
    auto toolset = Toolset{};

    auto primaryFile = handleArguments(args, toolset);
    if (primaryFile.empty())
	return 1;

    auto compilationUnits = std::list<CompilationUnit>{primaryFile};
    ScopeExit cleanup{[&] {
        for (auto& unit : compilationUnits)
            unit.removeTemporaryFiles();
    }};

    // We are about to start filling up the filesystem with temporary
    // files. To ensure these are deleted we must block signals that
    // are easily generated by the user (especially SIGINT). To avoid
    // becoming unresponsive we poll for signals each iteration of the
    // main loops (including the pre-pre-processor loop).
    hbcxx::block_signals();

    for (auto& unit : compilationUnits) {
	hbcxx::poll_signals();

	auto extraUnits = ppp.process(unit);
	toolset.pushFlags(unit.getFlags());

	// add any discovered units that are not already included
	for (auto& extraUnit : extraUnits) {
            auto i = std::find_if(std::begin(compilationUnits),
                                  std::end(compilationUnits),
                                  [&](const CompilationUnit& u) {
                return u.getInputFileName() == extraUnit.getInputFileName();
            });
            if (i == std::end(compilationUnits)) {
		if (Options::verbose())
                    std::cerr << "hbcxx: auto-discovered: "
                              << extraUnit.getInputFileName() << '\n';
                compilationUnits.push_back(extraUnit);
	    }
        }
    }

    for (auto& unit : compilationUnits) {
	hbcxx::poll_signals();
	toolset.compile(unit);
    }

    toolset.link(compilationUnits);
    cleanup.runEarly();

    if (!Options::executable().empty())
        return 0;

    auto launcher = makeLauncher();
    auto& primaryUnit = compilationUnits.front();

    auto res = launcher->launch(primaryUnit, args);
    if (!Options::saveTemps()) {
        auto fname = primaryUnit.getExecutableFileName();
        file::remove(fname);
	if (Options::verbose())
            std::cerr << "hbcxx: removed " << fname << '\n';
    }
    return hbcxx::propagate_status(res);
}

int main(int argc, const char* argv[])
{
    // we must process the options file before we process the command
    // line because we want the things on the command line to supercede
    // anything in the config file.
    auto home = std::getenv("HOME");
    auto rcfile = file::path{home ? home : ""} / ".hbcxx" / "hbcxxrc";
    Options::parseOptionsFile(rcfile.native());

    // arg0 gets special handling
    Options::handleArg0(argv[0]);

    // convert the arguments into an easily mutable form
    auto privateArgs = std::list<std::string>{};
    auto args = std::list<std::string>{};
    for (auto i=1; i<argc; i++) {
	auto arg = std::string{argv[i]};
	if (!Options::checkArgument(arg))
	    args.push_back(std::move(arg));
    }

    // command line tools can have *very* simple stop the world
    // exception handling models (or they could just call exit())
    try {
	// launch the alternative program is HBCXX_SUBSTITUTE_ARG0 is set
	if (std::getenv("HBCXX_SUBSTITUTE_ARG0"))
            return exec_wrapper(args);

        return run(args);
    }
    catch (PrePreProcessorError& te) {
	// PrePreProcessor should already have logged an error report
	return 127;
    }
    catch (ToolsetError& te) {
	// Toolset should already have logged an error report
	return 126;
    }
    catch (ArgumentError& ae) {
	std::cerr << PACKAGE_NAME << ": cannot find file to execute\n"
	          << "Try '" << PACKAGE_NAME << " --hbcxx-help' for more information.\n";
	return 125;
    }
    catch (hbcxx::signal_exception& se) {
	    hbcxx::unblock_signals();
            return 124; // unreachable
    }
    catch (std::exception& ex) {
	std::cerr << "Internal error: " << ex.what() << std::endl;
	return 124;
    }

}
